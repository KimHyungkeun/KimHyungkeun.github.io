---
title: OS Summary
date: 2024-01-23 00:00:00 +00:00
categories: [CS, OS]
tags:
  [
    CS,
    OS
  ]
---

# 1. **운영체제란**

- 하드웨어를 관리하고, 응용 프로그램과 하드웨어 사이에서 일어나는 작업이나 동작을 제어하는 소프트웨어

## (1) 프로세스 관리

- 운영체제에서 작동하는 응용프로그램을 관리
- CPU를 점유해야 할 프로세스를 결정하고, 실제로 CPU를 프로세스에 할당
- 프로세스 간 공유자원 접근과 통신 관리

## (2) 저장장치관리

1) 1차 저장장치(Main Memory)

- 프로세스에 할당하는 메모리 영역의 할당과 해제
- 각 메모리 영역 간의 침범 방지

2) 2차 저장장치(HDD, NAND Flash Memory)

- 파일 형식의 데이터 저장
- 파일 데이터 관리를 위한 파일시스템을 OS에서 관리
- (FAT, NTFS, EXT2, JFS, XFS)

## (3) 네트워킹

- TCP/IP 기반의 인터넷에 연결하거나, 응용 프로그램이 네트워크를 사용하려면 OS에서 네트워크 프로토콜을 지원해야한다. 현재 상용 OS들은 다양하고 많은 네트워크 프로토콜을 지원한다.

## (4) 사용자 관리

- 하나의 PC로도 여러 사람이 사용하는 경우가 많음
- 따라서, 운영체제는 각 계정을 관리할 수 있는 기능 필요
- 각 사용자별로 프라이버시 및 보안을 충실히 하여 외부접근이 불가능 하도록 해야함

## (5) 디바이스 드라이버

- OS는 시스템의 자원, 하드웨어를 관리
- 시스템에는 여러 하드웨어가 붙어있는데, 이들을 OS에서 인식하고 관리하게 만들어 응용프로그램이 하드웨어를 사용할 수 있도록 해야함
- 따라서, OS 내에서 하드웨어를 추상화 해주는 계층이 디바이스 드라이버

## (2/6 추가, OS 역할 정리)
- 시스템 자원 (System Resource) 관리자
  - CPU (중앙처리장치), Memory(DRAM, RAM)
  - I/O Device (입출력장치)
    - Monitor, Mouse, Keyboard, Network
  - 저장매체 : SSD, HDD (하드디스크)
- 사용자와 컴퓨터간의 커뮤니케이션 지원
  - 컴퓨터와 소통하기 위해 Shell과 같은 CLI 제공
- 응용 프로그램 제어

⇒ 운영체제의 목표 : 사용자가 사용하는 응용 프로그램이 효율적으로, 적절하게 동작하도록 지원

⇒ 운영체제는 응용프로그램이 요청하는 시스템 리소스를 효율적으로 분배하고 지원하는 소프트웨어

# 2. **프로세스와 스레드**

- 프로세스 : 프로그램이 메모리 상에서 실행중인 작업
- 스레드 : 프로세스 안에서 실행되는 여러 작업 흐름 단위

![Untitled](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/75803a5a-90f1-4ac2-9965-5ea47b69dec4)


프로세스는 각각 별도의 주소공간 할당(독립적)

- Code : 코드 자체를 구성하는 메모리 영역(프로그램 영령)
- Data : 전역변수, static변수, 배열 등(초기화된 데이터)
- Heap : 동적 할당 시 사용(new, malloc)
- Stack : 지역변수, 매개변수, 리턴 값(임시 메모리 영역)
    - 스레드는 Stack만 따로 할당 받고 나머지 영역은 공유
    - 하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드도 같이 생성

**프로세스는 자신만의 고유 공간과 자원을 할당 받는 반면, 스레드는 다른 스레드와 공간, 자원을 공유하면서 사용**

### (1) 멀티 프로세스

- 하나의 컴퓨터에 여러 CPU 장착 -> 하나의 프로세스들을 동시에 처리
- 장점 : 안전성(메모리 침범 문제를 OS 차원에서 해결)
- 단점 : 각각 독립된 메모리 영역을 가지므로, 작업량 많을수록 오버헤드 발생. Context Switching으로 인한 성능 저하

### (2) 멀티 스레드

- 하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리
- 장점 : 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소
- 단점 : 공유한 데이터를 Read/Write 하는 도중 동기화 이슈가 발생하면 비정상적인 동작이 발생할 수도 있음 (Stack을 제외한 나머지 영역은 모두 공유하므로)
    -> Critical Section(임계영역)을 통해 해결. 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려 할 때 발생하는 문제를 해결

### (3) 멀티 프로세스 vs 멀티 스레드 용도
- 멀티 프로세스 : 데이터를 Read/Write가 빈번하고 Mutex등의 동기화 기술이 많이 필요하게 될 경우에 고려
- 멀티 스레드 : Thread간 공유한 데이터를 읽기만 하는 등, 동기화 기술을 쓰지않고 데이터 통신을 위한 추가적인 기능 구현이 필요 없을 경우에 고려


# 3. **프로세스 주소 공간**

- 프로그램이 CPU에 의해 실행됨 -> 프로세스가 생성되고 메모리에 프로세스 주소공간 할당
- 프로세스 주소 공간에는 코드, 데이터, 스택으로 이루어짐

1) 코드 Segment : 프로그램 소스 코드 저장

2) 데이터 Segment : 전역 변수 저장

3) 스택 Segment : 지역변수, 함수 저장

### 구역을 나눈 이유

- 최대한 데이터를 공유하여 메모리 사용량을 최소화 하기 위해
- 특히 Stack과 Data를 나눈 이유는, 스택 구조의 특성과 전역 변수의 활용성을 위함
- 함수나 지역변수는 LIFO 특성을 가진 스택에서 실행되고, 전역변수는 따로 지정했다가 공통적으로 사용함으로써 메모리를 아낌

# 4. **인터럽트**

## (1) 정의

프로그램 실행 도중 예기치 않은 상황이 발생할 경우 현재 실행중인 작업을 즉시 중단하고, 발생된 상황을 우선 처리한 후, 진행중이던 작업으로 다시 복귀하는 것

- 외부 인터럽트 : 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생

- 내부 인터럽트 : Trap 이라고도 부름. 잘못된 명령이나 데이터 사용(0으로 나누기)

- 소프트웨어 인터럽트 : 프로그램 처리 중 명령의 요청에 의해 발생(SVC 인터럽트)

(사용자가 프로그램을 실행시킬 때 발생)

![Untitled 1](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/da81ba14-0ea8-4356-860a-bae422c1454e)


* 만약 인터럽트 기능이 없다면, 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야한다.(Polling)

### * 컨트롤러가 입력을 받아들이는 방법(우선순위 판별방법)에는 2가지가 있음

### 1) 폴링(Polling) 방식

- 사용자가 명령어를 사용해 입력핀의 값을 계속 읽어 변화를 알아냄

- 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 잧아 이에 맞는 인터럽트 서비스 루틴 수행

### 2) 인터럽트 방식

- 자체적으로 하드웨어 적인 변화를 체크하여 이상시에만 일정한 동작

- Daisy Chain, 병렬 우선순위 부여

- **실시간 대응이 필요할 때는 인터럽트 기능이 필수**

# 5. **시스템 콜**

- fork(), exec(), wait()와 같은 것들은 Process 생성과 제어를 위한 System call
- fork, exec는 새로운 프로세스 생성과 관련 있음
- wait는 부모 프로세스가 만든 자식 프로세스가 끝날 때 까지 기다리는 명령어

# 6. **PCB와 Context Swithching**

### (1) Process Management : 
CPU가 프로세스가 여러 개 일때, CPU스케쥴링을 통해 관리

* Process Metadata : 프로세스들의 특징과 정보를 갖고 있는 데이터

- Process ID, State, Priority, CPU Registers, Owner, CPU Usage, Memory Usage
- 이 메타데이터는 프로세스가 생성되면 PCB라는 곳에 저장됨

### (2) PCB(Process Control Block) : 프로세스 메타데이터를 저장하는 곳

프로그램 실행 -> 프로세스 생성 -> 프로세스 주소공간에(코드,데이터,스택)생성

-> 이 프로세스의 메타데이터들이 PCB에 저장

* PCB가 관리되는 방법

- Linked List 방식으로 관리된다.
- PCB들이 생성될 때 마다, 연결 리스트처럼 이어진다. 또한, 삽입,삭제가 용이

### (3) Context Switching

- CPU가 이전 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스가 새로 적재되는 작업
- Ready->Running, Running->Ready, Running->Waiting처럼 상태 변경 시 발생
- 즉, CPU에 계속 프로세스를 수행시키게 하기 위해 타 프로세스를 실행하고 Context Switching을 하는 것이다

* Context Switching의 Overhead

- 프로세스를 수행하다가 입출력 이벤트가 발생해서 대기 상태로 전환됨
- 이때, CPU를 그냥 방치하는 것 보다 다른 프로세스를 수행시키는 것이 효율적

# 7. **IPC(Inter Process Communication)**

- 개요
    - 프로세스는 독립적으로 실행된다. 하지만 이런 독립적인 프로세스 간의 통신을 해야하는 상황이 있을 것이다. 이를 가능하도록 해주는 것이 IPC 통신이다.
- 프로세스는 **커널**이 제공하는 IPC 설비를 이용해 프로세스간 통신이 가능.
  - **커널** : 운영체제의 핵심 부분. 다른 모든 부분에 대한 여러 기본적 서비스를 제공

## (1) IPC 종류

### 1) 익명 PIPE

- 파이프는 두 개의 프로세스를 연결하는데 한 프로세스는 Write만 다른 프로세스는 Read만 가능.
    
    ( **한쪽 방향으로만 통신이 가능한 반이중 통신** )
    
- 따라서, 양방향 송수신을 위해서는 2개의 파이프를 만들어야함.
- 장점 : 간단한 사용법, 단순한 데이터 흐름을 가질땐 파이프를 사용하는 것이 효율적
- 단점 : 전이중 통신을 위해 2개를 만들 경우, 구현이 복잡

### 2) Named PIPE (FIFO)

- 익명 파이프는 통신할 프로세스를 명확히 알 수 있는 경우에 사용
    
    ( ex : 부모-자식 프로세스 간 통신)
    
- 반면, Named 파이프는 전혀 모르는 상태의 프로세스들 사이 통신에 사용
- **즉, 부모 프로세스와 무관한 다른 프로세스도 통신이 가능**
- Named PIPE 또한 읽기/쓰기가 동시에 불가능하므로, 익명파이프처럼 PIPE 2개가 필요

### 3) 메시지 큐 (Message Queue)
- FIFO 자료 구조
- 입출력 방식은 Named PIPE와 동일
- 차이점은 메시지 큐는 파이프와 같은 데이터 흐름이 아닌 메모리 공간
- **사용할 데이터에 번호를 붙여서 여러 프로세스가 동시에 데이터를 쉽게 다룰 수 있다**

### 4) 공유 메모리 (Shared memory)
- 파이프, 메시지 큐는 통신을 이용한 설비지만 **공유 메모리는 데이터 자체를 공유**하도록 지원하는 설비
  - 보통, 프로세스 메모리 영역은 독립적이며 타 프로세스의 접근을 불가하지만 다른 프로세스가 데이터를 사용하도록 해야 하는 상황도 온다. 
  - 따라서, 스레드처럼 메모리를 공유하도록 해준다면 더욱 편할 것이다.
- **공유 메모리는 프로세스간 메모리 영역을 공유해서 사용하도록 허용**
- **중개자 없이 곧바로 메모리에 접근가능하므로 IPC 중에 가장 빠름**

### 5) 메모리 맵 (Memory Map)
- 메모리 맵은 열린 파일을 메모리에 맵핑시켜서 공유하는 방식
  - **(즉, 공유 매개체가 파일 + 메모리)**  
- 주로 파일로 대용량 데이터를 공유해야 할 때 사용

### 6) 소켓 (Socket)
- 네트워크 소켓 통신을 통해 데이터 공유
- 클라이언트와 서버가 소켓을 통해서 통신하는 구조. 원격에서 프로세스 간 데이터를 공유 시 사용
- 이러한 IPC통신에서 프로세스 간 데이터를 동기화하고 보호하기위해 세마포어와 뮤텍스를 사용. (공유된 자원에 한번에 하나의 프로세스만 접근시킬 때)

### 7) 세마포어 (Semaphore)
-  Semaphore는 프로세스 간 데이터를 동기화 하고 보호하는데 그 목적을 두게 됨. 
- 프로세스간 메시지 전송을 하거나, 혹은 Shared Memory를 통해서 특정 데이터를 공유하게 될 경우 발생하는 문제가 공유된 자원에 여러개의 프로세스가 동시에 접근하면 안되며, 단지 한번에 하나의 프로세스만 접근 가능하도록 만들어줘야 함.


# 8. **CPU 스케쥴링**

## (1) 스케쥴링 : CPU의 효율적 이용을 위한 프로세스 배정 작업

**프로세스가 생성되어 실행될때 필요한 자원을 해당 프로세스에 할당하는 작업을 말함**

- 조건 : 오버헤드 낮춤 / 사용률 높임 / 기아 현상 낮춤
- 목표 :

1) Batch system : 가능하면 시간 내에 많은 일을 수행. 처리량(Throughout)이 우선

2) Interactive System : 빠른 응답시간, 적은 대기시간

3) Realtime System : 기한(deadline) 맞추기

## (2) 선점 / 비선점 스케쥴링

1) 선점(preemptive) : OS가 CPU 사용권을 선점할 수 있는 경우, 강제 회수 하는 경우

2) 비선점(nonpreemptive) : 프로세스 종료 or I/O 등의 이벤트가 있을 때 까지 실행보장

## (3) CPU 스케쥴링의 종류

1) 비선점 스케쥴링

- FCFS(First Come First Served) : 큐에 도착한 순서대로 CPU 할당
- SJF(Shortest Job First) : 수행시간이 가장 짧다고 판단되는 작업을 먼저 수행
- HRN(Highest Response-ratio Next) : 우선순위 = (대기시간 + 실행시간) / (실행시간)
- Priority Scheduling

2) 선점 스케쥴링

- Round Robin
- SRT(Shortest Remaining Time)
- Multilevel Queue
- Multilevel-Feedback Queue

## (4) CPU 스케쥴링 척도

1) Response Time : 작업이 처음 실행되기까지 걸린 시간

2) Turnaround Time : 실행시간과 대기시간을 모두 합해 총 작업시간을 구함

# 9. **데드락(Deadlock)**

- 프로세스가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
- 시스템적으로 한정된 자원을 여러 곳에서 사용하려 할 때 발생

![Untitled 2](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/717bc0ba-db91-4f6f-93a1-b83923cf2b7c)


- 프로세스1이 자원1을 get / 프로세스2가 자원 2을 get
- 프로세스1이 자원2을 wait / 프로세스2가 자원 1을 wait

## (1) Deadlock 발생 조건(아래 4가지 모두 성립)

1) 상호 배제 : 자원은 한번에 한 프로세스만 사용 가능

2) 점유 대기 : 최소 하나의 자원을 점유한 상태로, 다른 프로세스에 할당되어 사용하는 자원을 추가 점유하기 위해 대기하는 프로세스가 있어야 함

3) 비선점 : 다른 프로세스에 할당된 자원은 강제로 빼앗을 수 없음

4) 순환 대기 : 프로세스의 집합에서 순환 형태로 자원을 대기

## (2) Deadlock 처리

1) 예방(Prevention) : 교착 상태 4가지 조건 중 하나를 제거(자원 낭비 심함)

- 상호배제 부정 : 여러 프로세스가 공유 자원 사용
- 점유대기 부정 : 프로세스 실행 전 모든 자원 할당
- 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때, 가진 자원 반납
- 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구

2) 회피(avoidance) : 교착 상태 발생 시 피해 나감

- 은행원 알고리즘
    - 프로세스가 자원 요구 시, 시스템은 할당 후에도 안정상태로 남아있는지 사전 검사
    - 안정 상태면 자원할당, 아니면 다른 프로세스들이 자원 해지 할 때까지 대기

3) 탐지(Detection) : 자원 할당 그래프를 통해 교착 상태를 탐지

4) 회복(Recovery) : 교착을 일으킨 프로세스를 종료하거나, 할당된 자원을 해제 후 회복

- 프로세스 종료 방법 : 교착 상태 프로세스를 모두 중지, 교착상태 제거될 때 까지 중지
- 자원 선점 방법 : 교착상태의 프로세스가 점유한 자원을 선점하여 다른 프로세스에게 할당, 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점

# 10. **경쟁 상태(Race condition)**

- 공유 자원에 대해 여러 프로세스가 접근할 때, 결과에 영향을 줄 수 있는 상태

### 1) 커널 작업을 수행하는 중에 인터럽트 발생

### 2) 프로세스가 System Call 하여 커널 모드로 진입하여 작업을 수행하는 도중 Context Switching 발생

문제 : 프로세스1이 커널모드에서 데이터 조작 중, 시간초과로 CPU제어권이 프로세스2로 넘어가 같은 데이터를 조작할 때

해결 : 프로세스가 커널모드에서 작업할 때, 시간초과여도 CPU제어권이 다른 프로세스에게 넘어가지 않게 함

### 3) 멀티 프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때

문제 : 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근

해결 : 커널 내부의 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock 함

# 11. **세마포어와 뮤텍스**

## 1) 뮤텍스(Mutex) 
- 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술 (접근 조율을 위해 lock & unlock으로 나뉨)
- 임계구역에 **하나의 Thread**만 들어갈 수 있음
    
  - lock : 현재 임계 구역에 들어갈 권한 얻음. (다른 프로세스/스레드가 임계구역 수행 중중이 종료할 때 까지 대기)
    
  - unlock : 현재 임계 구역을 모두 사용했음을 알림. (이 시점부터 다른 프로세스/스레드가 임계 구역에 진입 가능)
    
- **뮤텍스 알고리즘**
    
1) 데커 알고리즘 : flag/turn 변수를 통해 임계 구역에 들어갈 프로세스/스레드 결정
- flag: 프로세스 중 누가 임계영역에 진입
- turn : 누가 임계구역에 들어갈 차레인지
    
2) 피터슨 알고리즘 : 데커와 유사하나 상대방 프로세스/스레드에게 진입 기회를 양보
    
3) 제과점 알고리즘 : 여러 프로세스/스레드에 대한 처리가 가능한 알고리즘. 가장 작은 수의 번호표를 가진 프로세스가 임계구역에 진입

## 2) 세마포어(Semaphore) 
- 공유된 자원에 여러 프로세스가 접근하면 문제가 발생할 수 있음
- 따라서, 공유된 자원은 한번에 하나의 프로세스만 접근할 수 있도록 제한필요
- 세마포어의 경우 ***임계구역**에 **여러 Thread**가 들어갈 수 있음
- **counter**를 두어서 동시에 리소스에 접근할 수 있는 허용가능한 Thread 수를 제어

***임계 구역(Critical Section)** 
- 여러 프로세스가 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분. 한 프로세스가 임계 구역을 수행할 때는 다른 프로세스는 접근을 금한다.

    

# 12. **페이징과 세그먼테이션**

## 기법을 쓰는 이유 :

다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 작업이 필요하므로

1. 메모리 관리기법

1) 연속 메모리 관리 : 프로그램 전체가 하나의 커다란 공간에 연속 할당

- 고정 분할 : 주기억장치가 고정된 파티션으로 분할(내부단편화 위험)

(균등분할, 비균등분할)

- 동적 분할 : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재

(first-fit, next-fit, best-fit) (외부단편화 위험)

2) 불연속 메모리 관리 : 프로그램의 일부가 서로 다른 주소 공간에 할당

- 페이지 : 고정사이즈의 작은 프로세스 조각

- 프레임 : 페이지 크기와 같은 주기억장치 메모리 조각

- 단편화 : 기억 장치의 빈 공간 or 자료가 여러 조각으로 나뉨

- 세그먼트 : 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치

* 고정 크기 : 페이징(Paging)

* 가변 크기 : 세그멘테이션(Segmentation)

## (1) **메모리 관리 배경**

각각의 **프로세스** 는 독립된 메모리 공간을 갖고, 운영체제 혹은 다른 프로세스의 메모리 공간에 접근할 수 없는 제한이 걸려있다. 단지, **운영체제** 만이 운영체제 메모리 영역과 사용자 메모리 영역의 접근에 제약을 받지 않는다.

**Swapping** : 메모리의 관리를 위해 사용되는 기법. 표준 Swapping 방식으로는 round-robin 과 같은 스케줄링의 다중 프로그래밍 환경에서 CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(e.g. 하드디스크)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다.

> 이 과정을 swap (스왑시킨다) 이라 한다. 주 기억장치(RAM)으로 불러오는 과정을 swap-in, 보조 기억장치로 내보내는 과정을 swap-out 이라 한다. swap 에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할때 Swapping 이 시작된다.
> 

**단편화** (**Fragmentation**) : 프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면, 프로세스들이 차지하는 메모리 틈 사이에 사용 하지 못할 만큼의 작은 자유공간들이 늘어나게 되는데, 이것이 **단편화** 이다. 단편화는 2 가지 종류로 나뉜다.

![Untitled 3](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/541cea48-c5dd-429e-abfa-bb30f0d1ecbe)


- 외부 단편화: 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들을 모두 합치면 충분한 공간이 되는 부분들이 **분산되어 있을때 발생한다고 볼 수 있다.**
- 내부 단편화: 프로세스가 사용하는 메모리 공간 에 포함된 남는 부분. 예를들어 **메모리 분할 자유 공간이 10,000B 있고 Process A 가 9,998B 사용하게되면 2B 라는 차이** 가 존재하고, 이 현상을 내부 단편화라 칭한다.

압축 : 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아, 자유공간을 확보하는 방법론 이지만, 작업효율이 좋지 않다. (위의 메모리 현황이 압축을 통해 아래의 그림 처럼 바뀌는 효과를 가질 수 있다)

![Untitled 4](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/3632a71c-4043-4893-b3f3-ad1d645316bd)


## **Paging(페이징)**

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다. 외부 단편화와 압축 작업을 해소 하기 위해 생긴 방법론으로, 물리 메모리는 Frame 이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다.(페이지 교체 알고리즘에 들어가는 페이지)

페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있는 큰 장점이 있다.

하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나뉘어서 관리되고(논리 메모리에서), 개별 페이지는 **순서에 상관없이** 물리 메모리에 있는 프레임에 mapping 되어 저장된다고 볼 수 있다.

- 단점 : 내부 단편화 문제의 비중이 늘어나게 된다. 예를들어 페이지 크기가 1,024B 이고 **프로세스 A** 가 3,172B 의 메모리를 요구한다면 3 개의 페이지 프레임(1,024 * 3 = 3,072) 하고도 100B 가 남기때문에 총 4 개의 페이지 프레임이 필요한 것이다. 결론적으로 4 번째 페이지 프레임에는 924B(1,024 - 100)의 여유 공간이 남게 되는 내부 단편화 문제가 발생하는 것이다.

## **Segmentation(세그멘테이션)**

페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할 사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위) 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장

- 단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(외부 단편화)

# **13. 가상 메모리**

다중 프로그래밍을 실현하기 위해서는 많은 프로세스들을 동시에 메모리에 올려두어야 한다. 가상메모리는 **프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법** 이며, 프로그램이 물리 메모리보다 커도 된다는 주요 장점이 있다.

하드디스크의 일부를 마치 메모리처럼 사용할 수 있게 해주는 기술을 말한다.

## **1) 가상 메모리 개발 배경**

실행되는 **코드의 전부를 물리 메모리에 존재시켜야** 했고, **메모리 용량보다 큰 프로그램은 실행시킬 수 없었다.** 또한, 여러 프로그램을 동시에 메모리에 올리기에는 용량의 한계와, 페이지 교체등의 성능 이슈가 발생하게 된다. 또한, 가끔만 사용되는 코드가 차지하는 메모리들을 확인할 수 있다는 점에서, 불필요하게 전체의 프로그램이 메모리에 올라와 있어야 하는게 아니라는 것을 알 수 있다.

## **2) 프로그램의 일부분만 메모리에 올릴 수 있다면...**

- 물리 메모리 크기에 제약받지 않게 된다.
- 더 많은 프로그램을 동시에 실행할 수 있게 된다. 이에 따라 `응답시간`은 유지되고, `CPU 이용률`과 `처리율`은 높아진다.
- swap에 필요한 입출력이 줄어들기 때문에 프로그램들이 빠르게 실행된다.

## **3) 가상 메모리가 하는 일**

가상 메모리는 실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것으로 정리할 수 있다. 이로써 작은 메모리를 가지고도 얼마든지 큰 `가상 주소 공간`을 프로그래머에게 제공할 수 있다.

## **4) 가상 주소 공간**

- 한 프로세스가 메모리에 저장되는 논리적인 모습을 가상메모리에 구현한 공간이다. 프로세스가 요구하는 메모리 공간을 가상메모리에서 제공함으로써 현재 직접적으로 필요치 않은 메모리 공간은 실제 물리 메모리에 올리지 않는 것으로 물리 메모리를 절약할 수 있다.
- 예를 들어, 한 프로그램이 실행되며 논리 메모리로 100KB 가 요구되었다고 하자. 하지만 실행까지에 필요한 메모리 공간`(Heap영역, Stack 영역, 코드, 데이터)`의 합이 40KB 라면, 실제 물리 메모리에는 40KB 만 올라가 있고, 나머지 60KB 만큼은 필요시에 물리메모리에 요구한다고 이해할 수 있겠다.

![Untitled 5](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/c0c8eb4b-ad1a-4174-8586-1e8b4f2ce569)


# **14. Demand Paging(요구 페이징)**

프로그램 실행 시작 시에 프로그램 전체를 디스크에서 물리 메모리에 적재하는 대신, 초기에 필요한 것들만 적재하는 전략을 `요구 페이징`이라 하며, 가상 메모리 시스템에서 많이 사용된다. 그리고 가상 메모리는 대개 [페이지](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#paging%ED%8E%98%EC%9D%B4%EC%A7%95)로 관리된다. 요구 페이징을 사용하는 가상 메모리에서는 실행과정에서 필요해질 때 페이지들이 적재된다. **한 번도 접근되지 않은 페이지는 물리 메모리에 적재되지 않는다.**

프로세스 내의 개별 페이지들은 `페이저(pager)`에 의해 관리된다. 페이저는 프로세스 실행에 실제 필요한 페이지들만 메모리로 읽어 옮으로써, **사용되지 않을 페이지를 가져오는 시간낭비와 메모리 낭비를 줄일 수 있다.**

## **Page fault trap(페이지 부재 트랩)**

### **페이지 교체**

`요구 페이징` 에서 언급된대로 프로그램 실행시에 모든 항목이 물리 메모리에 올라오지 않기 때문에, 프로세스의 동작에 필요한 페이지를 요청하는 과정에서 `page fault(페이지 부재)`가 발생하게 되면, 원하는 페이지를 보조저장장치에서 가져오게 된다. 하지만, 만약 물리 메모리가 모두 사용중인 상황이라면, 페이지 교체가 이뤄져야 한다.(또는, 운영체제가 프로세스를 강제 종료하는 방법이 있다.)

출처 : [https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#메모리-관리-전략](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5)

# 14. **페이지 교체 알고리즘**

1) FIFO 알고리즘 : 메모리에 먼저 올라온 페이지를 먼저 내보냄

![Untitled 6](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/eafe6f03-dda5-43f8-8cf6-0b638331c751)


2) OPT 알고리즘 (Optimal) : 앞으로 사용하지 않을 페이지를 우선 내보냄

![Untitled 7](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/d3cb4d95-5944-4adf-8f07-f4e03546336f)


3) LRU 알고리즘 (Least-Recently Used) : 최근 사용하지 않은 페이지를 내보냄

![Untitled 8](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/35ebc61a-96ad-4d7d-97f2-ed4e63838399)


- 교체 방식

* Global 교체 : 메모리 상의 모든 프로세스 페이지에 대해 교체하는 방식

* Local 교체 : 메모리 상의 자기 프로세스 페이지에서만 교체하는 방식

-> 다중 프로그래밍의 경우, 메인 메모리에 다양한 프로세스가 동시에 올라올 수 있으므로 다양한 프로세스 페이지가 메모리에 존대

# 15. **메모리**

## (1) 메인 메모리(Main Memory)

- 메인 메모리는 CPU가 직접 접근 가능한 접근장치.
- 프로세스가 실행되려면 프로그램이 메모리에 올라와야 함

### MMU(Memory Management Unit)

- 논리주소를 물리주소로 변환
- CPU가 메모리에 접근하는 것을 총 관리 해주는 하드웨어
- 한정적인 메모리공간으로 인해, 사용자에게 더 많은 메모리 제공을 위해서 ‘가상주소’라는 개념 등장. 이 가상주소에서 실제 데이터가 담긴 곳에 접근하기 위해 빠른 주소변환이 필요한데, 이를 MMU가 도와준다.
- 메인 메모리의 직접 접근은 비효율적이므로, CPU와 메인메모리 속도를 맞추기 위해 캐시가 존재

### TLB (Translation Lookaside Buffer)
- 가상주소를 물리주소로 변환하는 속도를 높이기 위해 사용하는 캐쉬

### MMU의 메모리 보호

- 프로세스는 독립적인 메모리 공간을 가져야 되고, 자신의 공간만 접근해야 함
- 따라서 잘못된 접근이 오면 trap을 발생시키며 보호

![Untitled 9](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/d72d4b6f-b0b5-4372-9ed8-c33250c9fc75)


- base 레지스터 : 메모리상의 프로세스 시작주소를 물리주소로 저장
- limit 레지스터 : 프로세스의 사이즈를 저장
- 위 영역을 벗어난 곳에서 접근을 요구하면 trap을 발생시킴
- 안전성을 위해 base와 limit 레지스터는 커널 모드에서만 수정 가능하도록 설계

## (2) 캐시 메모리(Cache Memory)

- 주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치
- CPU와 주기억장치의 속도 차이로 인한 성능 저하를 방지

### 1) CPU와 기억장치의 상호작용

- CPU에서 주소를 전달 -> 캐시 기억장치에 명령이 존재하는지 확인

1) (존재) Hit : 해당 명령어를 CPU로 전송 -> 완료

2) (비존재) Miss : 명령어를 갖고 주기억장치로 접근 -> 해당 명령어를 가진 데이터 인출 -> 해당 명령어 데이터를 캐시에 저장 -> 해당 명령어를 CPU로 전송 -> 완료

### 2) 지역성의 원리

- 지역성 : 기억장치 내의 정보를 균일하게 액세스 하는 것이 아니라 한 순간에 특정 부분을 집중적으로 참조
    
    1) 시간 지역성 : 최근에 참조된 주소의 내용은 곧 다음에도 참조
    
    2) 공간 지역성 : 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 재참조
    
- 캐싱 라인
    - 빈번하게 사용되는 데이터를 캐시에 저장했어도, 내가 필요한 데이터를 캐시에서 찾을때 모두 순회하는 것은 시간 낭비
    - 즉, 캐시에 데이터를 저정할 시, 자료구조를 활용해 묶어서 저장하여 원하는 데이터를 얻을 수 있도록 하는 것이 캐싱 라인
