---
title: OS 퀴즈
date: YYYY-MM-DD HH:MM:SS +00:00
categories: [CS, OS]
tags:
  [
    CS,
    OS
  ]
---

# 운영체제 퀴즈

**출처:** [https://csbroker.io/problem?page=1](https://csbroker.io/problem?page=1) (카테고리 : 운영체제)

---
**1. Process**  
- 운영체제로부터 시스템 자원을 할당받는 작업의 단위
- CPU는 PCB를 통해 Process를 관리
- 프로그램은 하드디스크에 저장되어 있고 Process는 메모리에 저장
- 하나의 실행중인 프로그램에서 Process는 하나 일수도 있고 여러개 일수도 있다
- PCB(Process Control Block)는 커널 주소 공간의 데이터 영역에 저장

**2. Thread**  
- 할당받은 자원을 이용하는 실행의 단위
- 메모리의 관점에서 Thread Process의 Code, Data, Heap 영역을 공유받지만, Stack 영역은 독립적으로 존재
- Thread는 실행중인 Process 내에서 실제로 작업을 수행하는 주체
- 하나의 Process는 무조건 하나 이상의 Thread를 가짐

**3. 멀티 Thread 특징 (멀티 Process와 비교했을 때)**  
- ***Context Switching** 비용이 적음
- 공유자원에 접근하기 편리
- 메모리 공간을 덜 차지
- 동시성 처리 속도가 빠름
- 여러 Thread가 공유 자원에 동시 접근 가능하기때문에, 동기화 문제에 신경써야 함 

  - ***(참고) Context Switching** : 다른 Process 처리를 위해 기존에 실행중이던 Process에 대한 작업을 저장하고 다른 Process의 상태 값을 읽어 적용하는 것을 의미

**4. 부모 Process와 자식 Process**  
- 부모 Process가 fork 명령어를 통해 자식 Process 생성
- 자식 Process 활용 후, 부모Process는 wait 명령어를 통해 자식 Process의 자원을 수거
- 만약, 부모 Process가 wait 명령어 없이 먼저 종료해버린다면 자식 Process는 고아 Process로 변경
=> 자식 Process의 ppid가 init Process의 ID인 1로 변경
- init Process는 고아 Process의 작업이 끝나면 wait을 통해 자원을 회수

**5. 컴파일러(Compiler)**  
  - 프로그램 전체를 한 번에 컴파일링 
  - 컴파일러는 실행 전에 오류 발견 가능
  - 컴퓨터의 프로세서에 따라 컴파일링 되는 코드 각각 다를 수 있음

**6. 컴파일(Compile) 순서**  
  - 전처리(Preprocessing) : 소스코드를 전처리 시킨 .i 파일 생성
  - 컴파일(Compiling) : 전처리된 코드 파일을 컴파일 시켜 어셈블리어 파일(.s) 생성
  - 어셈블리(Assembly) : 어셈블리어 파일(.s)를 오브젝트 파일(.o)로 생성
  - 링킹(Linking) : 오브젝트 파일을 이용해 실행파일 생성
![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FGb9WO%2FbtrdpL4fvcQ%2Fspc9IYinoZhgHRmJ0l0kjK%2Fimg.png)

**7. 인터프리터(Interpreter)**  
  - 인터프리터는 프로그램 실행 시 한 번에 한 문장씩 번역하는 컴파일링 방식
  - 컴파일러에 비해 실행 시간이 느림
  - 오류를 실행 도중에 발견하기에 예상치 못한 버그에 취약
  - OS나 플랫폼에 종속되지 않음

**8. 인터프리터(Interpreter)와 컴파일러(Compiler)의 차이**  
- 컴파일러는 인터프리터에 비해 처음 빌드할 때 시간이 오래 소요
- 대신 빌드를 하고 난 뒤부터는 **Binary 실행파일만 실행**하면 되기 때문에 실행시간이 인터프리터 방식보다 빠름
- 하지만 컴파일러는 **한 번에 전체 코드를 빌드**해야하기 때문에 한 줄씩 메모리에 담는 인터프리터 방식보다는 메모리 효율이 좋지 않음
- 컴파일러는 빌드를 하는 과정 중 오류를 검출
- 인터프리터는 실행과정에서 오류가 검출

**9. 프로세스(Process)간 통신**  
- 프로세스는 독립적인 메모리 공간을 갖기 때문에 서로의 영역 침범 불가
- 이 때 서로 통신을 하거나 자원을 공유하는 방법으로 IPC(Inter Process Communication) 방식 사용
- IPC 방법으로 공유메모리, 파이프, 소켓, 메세지큐 등의 방법이 존재



**10. DeadLock 발생 조건**
- **상호배제** : 한 번에 프로세스 하나만 해당 자원을 사용 가능. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때 까지 대기
- **점유대기** : 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재 해야함
- **비선점** : 이미 할당된 자원을 강제로 뺏는 것은 불가
- **순환대기** : 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 함

**11. 쿠키(Cookie)와 세션(Session)**
- **저장 위치 관점**
  - 쿠키는 클라이언트 측에 저장되고 세션은 서버 측에 저장
  - 세션은 서버를 거쳐야 하기 때문에 쿠키보다 속도가 느린 대신 보안에 유리

- **라이프사이클(LifeCycle) 관점**
  - 쿠키와 세션은 모두 만료기간을 정해 놓음
  - 세션은 브라우저가 종료되면 세션 스토리지에 세션 아이디가 사라지기 때문에 만료기간에 상관없이 삭제

**12. 라운드로빈(Round Robin)**
- CPU는 한 번에 하나의 프로세스에 대한 일이 가능
- 각 프로세스에 일정시간을 할당하고, 할당된 시간이 지나면 그 프로세스는 잠시 보류한 뒤 다른 프로세스에게 기회를 주고, 또 그 다음 프로세스에게 기회를 주는 방식으로 순환을 진행하는 알고리즘

**13. 스택프레임(Stack Frame)**
- 함수가 호출되면 스택에는 함수의 매개변수, 호출이 끝난 뒤 돌아갈 반환 주소 값, 함수에서 선언된 지역 변수 등이 저장
- 이렇게 스택 영역에 차례대로 저장될 때, 함수를 구분하기 위해 생성되는 공간을 스택프레임이라 한다.


**14. 가상 메모리(Virtual Memory)**
- 가상 메모리는 Process 전체가 메모리에 올라오지 않더라도 실행이 가능하도록 하는 기법
- 물리 메모리 개념과 논리 메모리 개념을 분리

**15. 쓰레싱(Thrashing)**
- 메모리 영역에 접근하게 될 때, 메모리의 페이지 부재(page fault)율이 높아 프로세스 수행시간보다 페이지 교체시간이 많은 상태를 일컫는다.

**16. 페이징(Paging) 기법**
- 프로세스가 할당받은 메모리 공간을 일정한 페이지 단위로 나누는 메모리 관리 기법
- 물리 메모리에서 연속되지 않은 서로 다른위치에 저장하도록 함

**17. 세그멘테이션(Segmentation)**
- 프로세스가 할당바든 메모리 공간을 논리적 의미 단위인 세그먼트로 나누어, 연속되지 않음 물리 메모리 공간에 할당될 수 있도록 하는 메모리 관리 기법
=> (논리적 의미 단위는 Code, Data, Stack, Heap 영역을 의미)
- 논리적 의미 단위로 나누기 때문에 내부 단편화 문제가 없으나 외부 단편화 문제가 존재
---
