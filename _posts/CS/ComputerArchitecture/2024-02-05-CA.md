---
title: Computer Architecture Summary
date: 2024-02-05 00:00:00 +00:00
categories: [CS, ComputerArchitecture]
tags:
  [
    CS,
    ComputerArchitecture
  ]
---

# 1. **컴퓨터의 구성**

- 컴퓨터 시스템은 하드웨어와 소프트웨어로 나뉨
    - 하드웨어 : 컴퓨터를 구성하는 기계적 장치
    
    (CPU, 기억장치(RAM, HDD), 입출력 장치(마우스, 프린터) 
    
    - 소프트웨어 : 하드웨어의 동작을 지시하고 제어
    - (시스템 소프트웨어 : OS, 컴파일러)
    - (응용 소프트웨어 : 워드프로세서, 스프레드시트)

**(1) 하드웨어**

![Untitled](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/c7db6232-79be-429b-b95e-d12015929412)


**1) CPU :** 주기억장치에서 프로그램 명령어와 데이터를 읽어와 처리하고 명령어의 수행순서 제어.

비교와 연산을 담당하는 **산술논리연산장치(ALU),**

명령어 해석과 실행을 담당하는 **제어장치**, 

속도가 빠른 데이터 기억장소인 **레지스터** 로 구성

**2) 기억장치 :** 프로그램, 데이터, 연산의 중간 결과를 저장

주기억장치(RAM, ROM)와 보조기억장치(HDD, SSD)로 나뉘며 주기억장치는 프로그램에 필요한 데이터를 일시적으로 저장하고 보조기억장치는 속도는 느리나 자료 영구보관

**3) 입출력장치 :** 입력(키보드, 마우스)과 출력(프린터, 모니터, 스피커 등)

**(2) 시스템 버스** 

요약 : 하드웨어 구성요소를 물리적으로 연결하는 선

1) 데이터 버스 : CPU와 기타 장치 사이에서 데이터를 전달하는 통로

2) 주소 버스 : 데이터를 정확히 실어나르기 위해 기억장치 “주소”를 정확히 기억

3) 제어 버스 : CPI가 기억장치나 입출력장치에 제어신호를 전달하는 통로

# 2. **CPU 작동 원리**

- CPU는 컴퓨터에서 가장 핵심적인 역할을 수행

**1) 연산 장치 :** 산술 연산과 논리 연산 수행. 연산에 필요한 데이터를 레지스터에서 가져오고, 연산 결과를 다시 레지스터로 보냄

**2) 제어 장치 :** 명령어를 순서대로 실행할 수 있도록 하는 제어장치. 주기억장치에서 프로그램 명령어를 꺼내 해독하고, 그 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄. 또한 이들 장치가 보낸 신호를 받아, 다음에 수행할 동작 결정

**3) 레지스터 :** 고속 기억장치. 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장. 용도에 따라 범용 레지스터와 특수목적 레지스터로 구분됨

**특수 목적 레지스터 중 중요한 것들**

1) MAR(메모리 주소 레지스터) : 읽기와 쓰기 연산을 수행할 주기억장치 주소 저장

2) PC(프로그램 카운터) : 다음에 수행할 명령어 주소 저장

3) IR(명령어 레지스터) : 현재 실행 중인 명령어 저장

4) MBR(메모리 버퍼 레지스터) : 주기억장치에서 읽어온 데이터 or 저장할 데이터 임시저장

5) AC(누산기) : 연산 결과 임시 저장

**CPU의 동작 과정**

1) 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어옴

2) CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억 장치에 저장

3) 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄

4) 제어장치는 1) ~ 3) 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어

# 3. **캐시 메모리**

- 속도가 빠른 장치와 느린 장치에서 속도 차이에 따른 병목현상을 줄이기 위한 메모리

ex1) CPU 코어와 메모리 사이의 병목 현상 완화

ex2) 웹 브라우저 캐시 파일은, HDD와 웹페이지 사이의 병목 현상을 완화

- CPU가 주기억장치에서 저장된 데이터를 읽어 올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤, 다음에 이용할 때 주기억장치가 아닌 캐시메모리에서 먼저 가져오면서 속도 향상
- CPU에는 이러한 캐시 메모리가 2~3개 정도 사용된다. 이는 속도와 크기에 다라 분류한 것으로 일반적으로 L1 캐시부터 먼저 사용.
    - (CPU에서 가장 빠르게 접근하는 것이 L1이고, 데이터를 찾지 못하면 L2로 간다

**듀얼 코어 프로세서의 캐시 메모리**

- 각 코어마다 독립된 L1 캐시메모리를 가지고, 두 코어가 공유하는 L2 캐시 메모리가 내장됨.
- L1이 CPU가 가장 빠르게 접근하게 되며, 여기서 데이터를 찾지 못하면, 이제 L2 캐시 메모리로 넘어간다.
    
    1) L1 : CPU 내부에 존재
    
    2) L2 : CPU 회로판에 별도의 칩으로 내장
    
    3) L3 : 보통 메인보드에 존재
    

**캐시 메모리 작동 원리**

1) 시간 지역성 : for나 while 같은 반복문에 사용하는 조건변수처럼 한번 참조된 데이터는 잠시 후 또 참조될 가능성 높음

2) 공간 지역성 : A[i], A[i+1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시 후 또 사용될 가능성이 높음

- 캐시에 데이터를 저장할때는, 이러한 참조 지역성(공간)을 최대한 활용하기 위해 해당 데이터 뿐 아니라, 옆 주소의 데이터도 같이 가져와 미래에 쓰일것을 대비

**캐시 미스 3가지**

1) Cold miss : 해당 메모리 주소를 처음 불러서 나는 미스

2) Conflict miss : 캐시 메모리에 A와 B 데이터를 저장해야 하는데, A와 B가 같은 캐시메모리 주소에 할당되어서 나는 미스

3) Capacity miss : 캐시 메모리 공간이 부족해서 나는 미스

-> 캐시 크기를 키워서 문제를 해결하려 하면, 접근속도가 느려지고 파워를 많이 먹음

**캐시 메모리 매핑 방법**

![Untitled 1](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/ad2c4ee7-a2fb-48f4-b51b-3792f9d0c9cb)


1) Direct Mapping : 캐시와 메모리 내에서 인덱스 비트 + 데이터 비트 + 태그 비트로 나누어서 원하는 장소에 맵핑

2) Full Associative : 캐시메모리에 빈공간이 발생하면 메모리 영역을 맵핑

3) Set Associative : Direct와 Full을 적절히 섞어서 사용

# 4. **고정 소수점 & 부동 소수점**

(1) 고정 소수점(Fixed Point) : 소수점이 찍힐 위치를 미리 정해놓고 소수 표현

예) -3.141592는 부호(-)와 정수부(3)와, 소수부(0,141592) 3가지 요소 필요

![Untitled 2](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/deff906d-4ab2-447f-bf60-1d6739ec3b99)


- 장점 : 실수를 정수부와 소수부로 표현하여 단순
- 단점 : 표현의 범위가 너무 적음(정수부는 15비트, 소수부는 16비트)

(2) 부동 소수점(Floating Point)

- 실수를 가수부 + 지수부로 표현
- 가수 : 실수의 실제값 표현
- 지수 : 크기를 표현. 가수의 어디쯤에 소수점이 있는지 나타냄

* 지수의 값에 따라 소수점이 움직이는 방식을 활용한 실수 표현방법

![Untitled 3](https://github.com/KimHyungkeun/KimHyungkeun.github.io/assets/12759500/6db96c60-6a69-4eb4-bffd-0375ab78308c)


- 장점 : 표현할 수 있는 수의 범위가 넓어짐.(현재 대부분 시스템에서 활용)
- 단점 : 오차 발생 확률 있음(부동소수점으로 표현할 수 있는 방법이 매우 다양)

# 5. **패리티 비트 & 해밍 코드**

**(1) 패리티 비트**

정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트

전송하고자 하는 데이터의 각 문자에 1비트를 더해 전송

- 종류 : 짝수, 홀수 (전체 비트에서 짝수나 홀수에 맞도록 비트를 정함)
- 예시 : 짝수 패리티일 때 7비트 데이터가 1010001라면?

-> 1이 총 3개이므로, 짝수를 맞추기위해 1을 더함 (답 : 11010001)

**(2) 해밍 코드**

데이터 전송 시 1비트의 에러를 정정할 수 있는 자기 오류정정 코드

- 방법 : 2의 n승 번째 자리인 1,2,4번째 자릿수가 패리티 비트라는 것으로부터 시작
- 예시 : 짝수 패리티의 해밍 코드가 0011011일 때 오류가 수정된 코드는?

1) 1,3,5,7번째 비트 확인 : 0101로 짝수이므로 ‘0’

2) 2,3,6,7번째 비트 확인 : 0111로 홀수이므로 ‘1’

3) 4,5,6,7번째 비트 확인 : 1011로 홀수이므로 ‘1’

역순으로 패리티비트 ‘110’을 도출. 10진법으로 바꾸면 ‘6’이므로, 6번째 비트 수정

(답 : 00110'0'1)
